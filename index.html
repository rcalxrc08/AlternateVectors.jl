<!doctype html>
<html lang="en">
<head>
  <!-- META -->
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="author" content="rcalxrc08">
  <title>AlternateVectors.jl</title>

  <link rel="icon" type="image/png"  href="/AlternateVectors.jl/assets/favicon.ico">

  <!-- CSS -->
  
   <link rel="stylesheet" href="/AlternateVectors.jl/libs/highlight/styles/atom-one-dark.css">
   
  <link rel="stylesheet" href="/AlternateVectors.jl/css/bootstrap.min.css">
  <style>.bg-primary {
  background-color: #3f6388 !important;
}

a {
  color: #2669DD;
}

a:hover {
  color: teal;
}

.section-bg-color {
  background-color: #f6f8fa;
}

footer a {
  color: cornflowerblue;
}


header {
  margin-top: 55px !important;
}



.jumbotron {
  background-image: url("assets/diagonal-lines.svg");
  background-repeat: repeat;
}


/* CODE ADJUSTMENTS */

pre code.hljs {
  border-radius: 10px;
}

pre code.hljs.plaintext {
  margin-left: 15px;
}
</style>
  <link rel="stylesheet" href="/AlternateVectors.jl/css/custom.css">

  <script async defer src="https://buttons.github.io/buttons.js"></script>
</head>
<body id="page-top">
  <nav class="navbar navbar-expand-lg navbar-dark bg-dark fixed-top" id="mainNav">
  <div class="container">
    <span class="navbar-brand">
      
        <img src="/AlternateVectors.jl/assets/logo.svg" class="img-fluid" style="height:         25px;
padding-right:  10px;
" alt="Logo"/>
      
      <a href="#page-top">AlternateVectors.jl</a>
      
    </span>
    <input type="checkbox" id="navbar-toggler-cbox" class="d-none" />
    <label for="navbar-toggler-cbox" class="navbar-toggler" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </label>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
        
        <li class="nav-item">
          <a class="nav-link" href="#about">About</a>
        </li>
        
        <li class="nav-item">
          <a class="nav-link" href="#usage">Usage</a>
        </li>
        
        <li class="nav-item">
          <a class="nav-link" href="#performances">Performances</a>
        </li>
        
      </ul>
    </div>
  </div>
</nav>

  <header class="text-white text-center">
  
    <div class="jumbotron jumbotron-fluid container-fluid bg-primary">
  
    <h1>AlternateVectors.jl</h1>
    <div class="lead">Peculiar Vector Patterns.
</div>
    
      <a class="github-button" href="https://github.com/rcalxrc08/AlternateVectors.jl" data-size="large" aria-label="View AlternateVectors.jl on GitHub">View on GitHub</a>
    
    
      <a class="github-button" href="https://github.com/rcalxrc08/AlternateVectors.jl" data-icon="octicon-star" data-size="large" data-show-count="true" aria-label="Star AlternateVectors.jl on GitHub">Star</a>
    
  </div>
</header>

  <!-- Content appended here -->
<div class="franklin-content"><section id="about" class="scrollspy">
  <div class="container">
    <div class="row">
      <div class="col-lg-10 mx-auto">
        <h2>About this Package</h2> <div class="lead">AlternateVectors.jl is a Julia package containing some useful array representation for peculiar one dimensional arrays patterns.</div> It currently contains the following immutable types:</p>
<ul>
<li><p>AlternateVector: convenient representation for vectors of the form:</p>
</li>
</ul>
<pre><code class="julia hljs">[a,b,a,b,a,b...]</code></pre>
<ul>
<li><p>AlternatePaddedVector: convenient representation for vectors of the form:</p>
</li>
</ul>
<pre><code class="julia hljs">[x,a,b,a,b,a,b...,y]</code></pre>
<p>The module is standalone.       </div>
    </div>
  </div>
</section>
<section id="usage" class="scrollspy section-bg-color">
  <div class="container">
    <div class="row">
      <div class="col-lg-10 mx-auto">
        <h2>Getting Started</h2> <strong><em>AlternateVector</em></strong></p>
<p>To build a AlternateVector one needs to provide:</p>
<ul>
<li><p>the value for odd indices</p>
</li>
<li><p>the value for even indices</p>
</li>
<li><p>the length.</p>
</li>
</ul>
<p>The various values must be of the same type and the length must be greater than one. The way to build an AlternateVector is the following:</p>
<pre><code class="julia hljs"><span class="hljs-keyword">using</span> AlternateVectors
value_odd=<span class="hljs-number">0.2</span>
value_even=<span class="hljs-number">2.3</span>
length_av=<span class="hljs-number">7</span>
x_av=AlternateVector(value_odd,value_even,length_av)</code></pre><pre><code class="plaintext hljs">7-element AlternateVector{Float64}:
 0.2
 2.3
 0.2
 2.3
 0.2
 2.3
 0.2</code></pre>
<p><strong><em>AlternatePaddedVector</em></strong></p>
<p>To build a AlternatePaddedVector one needs to provide: </p>
<ul>
<li><p>the initial value</p>
</li>
<li><p>the value for even indices</p>
</li>
<li><p>the value for odd indices</p>
</li>
<li><p>the final value</p>
</li>
<li><p>the length</p>
</li>
</ul>
<p>The various values must be of the same type and the length must be greater than three. The way to build an AlternatePaddedVector is the following:</p>
<pre><code class="julia hljs"><span class="hljs-keyword">using</span> AlternateVectors
initial_value=<span class="hljs-number">0.2</span>
value_odd=-<span class="hljs-number">0.2</span>
value_even=<span class="hljs-number">2.3</span>
final_value=<span class="hljs-number">1.3</span>
length_av=<span class="hljs-number">7</span>
x_av=AlternatePaddedVector(initial_value,value_even,value_odd,final_value,length_av)</code></pre><pre><code class="plaintext hljs">7-element AlternatePaddedVector{Float64}:
  0.2
  2.3
 -0.2
  2.3
 -0.2
  2.3
  1.3</code></pre>
<p><strong><em>Operation on Alternate Vectors</em></strong></p>
<p>The following applies:</p>
<ul>
<li><p>AlternateVector/AlternatePaddedVector is closed under getindex for range of integers.</p>
</li>
</ul>
<pre><code class="julia hljs"><span class="hljs-keyword">using</span> AlternateVectors
apv=AlternatePaddedVector(<span class="hljs-number">0.2</span>,-<span class="hljs-number">2.0</span>,<span class="hljs-number">4.0</span>,<span class="hljs-number">2.3</span>,<span class="hljs-number">70</span>)
z_small=apv[<span class="hljs-number">1</span>:<span class="hljs-number">7</span>:<span class="hljs-number">50</span>]
z_small</code></pre><pre><code class="plaintext hljs">8-element AlternatePaddedVector{Float64}:
  0.2
 -2.0
  4.0
 -2.0
  4.0
 -2.0
  4.0
 -2.0</code></pre>
<ul>
<li><p>Any scalar unary function applied directly to AlternateVectors/AlternatePaddedVector will produce an array of the same type.</p>
</li>
</ul>
<pre><code class="julia hljs"><span class="hljs-keyword">using</span> AlternateVectors
av=AlternateVector(<span class="hljs-number">0.2</span>,-<span class="hljs-number">2.0</span>,<span class="hljs-number">10</span>)
z_sin=@. sin(av)
z_sin</code></pre><pre><code class="plaintext hljs">10-element AlternateVector{Float64}:
  0.19866933079506122
 -0.9092974268256817
  0.19866933079506122
 -0.9092974268256817
  0.19866933079506122
 -0.9092974268256817
  0.19866933079506122
 -0.9092974268256817
  0.19866933079506122
 -0.9092974268256817</code></pre>
<p><strong><em>Operation between Alternate Vectors</em></strong></p>
<p>The following applies:</p>
<ul>
<li><p>Binary scalar functions between AlternateVector and AlternateVector will produce AlternateVector.</p>
</li>
<li><p>Binary scalar functions between AlternatePaddedVector and AlternatePaddedVector will produce AlternatePaddedVector.</p>
</li>
<li><p>Binary scalar functions between AlternatePaddedVector and AlternateVector will produce AlternatePaddedVector.</p>
</li>
<li><p>Binary scalar functions between AlternatePaddedVector/AlternateVector and <strong>any</strong> other type deriving from AbstractArray will produce an array of the other type.</p>
</li>
</ul>
<pre><code class="julia hljs"><span class="hljs-keyword">using</span> AlternateVectors
x=AlternateVector(<span class="hljs-number">0.2</span>,<span class="hljs-number">2.3</span>,<span class="hljs-number">10</span>)
y=randn(<span class="hljs-number">10</span>)
z=AlternatePaddedVector(<span class="hljs-number">0.2</span>,-<span class="hljs-number">2.0</span>,<span class="hljs-number">4.0</span>,<span class="hljs-number">2.3</span>,<span class="hljs-number">10</span>)
@. sin(x)*y+z</code></pre><pre><code class="plaintext hljs">10-element Vector{Float64}:
  0.22548976306849744
 -1.5146331718670174
  4.3768276648558055
 -1.191335265905449
  4.150447980488366
 -2.3904624151802745
  4.159450924605219
 -2.6286367214503965
  4.430356610809936
  3.7173682219870656</code></pre>
<p>      </div>
    </div>
  </div>
</section>
<section id="performances" class="scrollspy">
  <div class="container">
    <div class="row">
      <div class="col-lg-10 mx-auto">
        <h2>Performances Comparison</h2> Here the common usages of the package are tested.</p>
<p><strong><em>Simple multiplication</em></strong></p>
<pre><code class="julia hljs"><span class="hljs-keyword">using</span> AlternateVectors, BenchmarkTools
n=<span class="hljs-number">10_000</span>
x=AlternateVector(<span class="hljs-number">0.2</span>,<span class="hljs-number">2.3</span>,n)
y=randn(n)
x_c=collect(x)
<span class="hljs-meta">@btime</span> @. $x*$y;
<span class="hljs-meta">@btime</span> @. $x_c*$y;</code></pre><pre><code class="plaintext hljs">  2.135 μs (3 allocations: 78.20 KiB)
  2.848 μs (3 allocations: 78.20 KiB)
</code></pre>
<p><strong><em>Flipping sign based on index and sum</em></strong></p>
<pre><code class="julia hljs"><span class="hljs-keyword">using</span> AlternateVectors, BenchmarkTools, LinearAlgebra
n=<span class="hljs-number">10_000</span>
<span class="hljs-keyword">function</span> f_std_scalar(f_x)
	N=length(f_x)
	sum_z=zero(eltype(f_x))
	<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:N
		w=ifelse(isodd(i),<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>)
		sum_z+=<span class="hljs-meta">@views</span> <span class="hljs-meta">@inbounds</span> w*f_x[i]
	<span class="hljs-keyword">end</span>
	<span class="hljs-keyword">return</span> sum_z
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">function</span> f_std_scalar_2(f_x)
	N=length(f_x)
	sum_z=zero(eltype(f_x))
	<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:N
		<span class="hljs-keyword">if</span>(isodd(i))
			sum_z+=<span class="hljs-meta">@views</span> <span class="hljs-meta">@inbounds</span> f_x[i]
		<span class="hljs-keyword">else</span>
			sum_z-=<span class="hljs-meta">@views</span> <span class="hljs-meta">@inbounds</span> f_x[i]
		<span class="hljs-keyword">end</span>
	<span class="hljs-keyword">end</span>
	<span class="hljs-keyword">return</span> sum_z
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">function</span> f_std_vec(f_x)
	N=length(f_x)
	idx=<span class="hljs-number">1</span>:N
	W=@. ifelse(isodd(idx),<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>)
	<span class="hljs-keyword">return</span> sum(W.*f_x)
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">function</span> f_std_vec_linear_algebra(f_x)
	N=length(f_x)
	idx=<span class="hljs-number">1</span>:N
	W=@. ifelse(isodd(idx),<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>)
	<span class="hljs-keyword">return</span> dot(W,f_x)
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">function</span> f_apv(f_x)
	N=length(f_x)
	W=AlternateVector(<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,N)
	<span class="hljs-keyword">return</span> sum(W.*f_x)
<span class="hljs-keyword">end</span>
x=randn(n)
f_x=@. sin(x)+x*cos(x)
<span class="hljs-meta">@btime</span> f_std_scalar($f_x);
<span class="hljs-meta">@btime</span> f_std_scalar_2($f_x);
<span class="hljs-meta">@btime</span> f_std_vec($f_x);
<span class="hljs-meta">@btime</span> f_std_vec_linear_algebra($f_x);
<span class="hljs-meta">@btime</span> f_apv($f_x);</code></pre><pre><code class="plaintext hljs">  9.257 μs (0 allocations: 0 bytes)
  9.257 μs (0 allocations: 0 bytes)
  6.272 μs (6 allocations: 156.39 KiB)
  11.933 μs (2 allocations: 78.16 KiB)
  3.602 μs (3 allocations: 78.20 KiB)
</code></pre>
<p><strong><em>Simpson Integration</em></strong></p>
<pre><code class="julia hljs"><span class="hljs-keyword">using</span> AlternateVectors, BenchmarkTools,LinearAlgebra
n2=<span class="hljs-number">10_000</span>
<span class="hljs-keyword">function</span> f_simpson_std_scalar(f_x)
	N=length(f_x)
	sum_z=zero(eltype(f_x))
	<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:N
		w=ifelse(i==<span class="hljs-number">1</span>,<span class="hljs-number">1</span>/<span class="hljs-number">3</span>,ifelse(i==N,<span class="hljs-number">1</span>/<span class="hljs-number">3</span>,<span class="hljs-number">4</span>/<span class="hljs-number">3</span>))
		sum_z+=<span class="hljs-meta">@views</span> <span class="hljs-meta">@inbounds</span> w*f_x[i]
	<span class="hljs-keyword">end</span>
	<span class="hljs-keyword">return</span> sum_z
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">function</span> f_simpson_std_vec(f_x)
	N=length(f_x)
	idx=<span class="hljs-number">1</span>:N
	W=@. ifelse(idx==<span class="hljs-number">1</span>,<span class="hljs-number">1</span>/<span class="hljs-number">3</span>,ifelse(idx==N,<span class="hljs-number">1</span>/<span class="hljs-number">3</span>,<span class="hljs-number">4</span>/<span class="hljs-number">3</span>))
	<span class="hljs-keyword">return</span> sum(W.*f_x)
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">function</span> f_simpson_std_vec_linear_algebra(f_x)
	N=length(f_x)
	idx=<span class="hljs-number">1</span>:N
	W=@. ifelse(idx==<span class="hljs-number">1</span>,<span class="hljs-number">1</span>/<span class="hljs-number">3</span>,ifelse(idx==N,<span class="hljs-number">1</span>/<span class="hljs-number">3</span>,<span class="hljs-number">4</span>/<span class="hljs-number">3</span>))
	<span class="hljs-keyword">return</span> dot(W,f_x)
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">function</span> f_simpson_apv(f_x)
	N=length(f_x)
	W=AlternatePaddedVector(<span class="hljs-number">1</span>/<span class="hljs-number">3</span>,<span class="hljs-number">4</span>/<span class="hljs-number">3</span>,<span class="hljs-number">4</span>/<span class="hljs-number">3</span>,<span class="hljs-number">1</span>/<span class="hljs-number">3</span>,N)
	<span class="hljs-keyword">return</span> sum(W.*f_x)
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">function</span> f_simpson_apv_linear_algebra(f_x)
	N=length(f_x)
	W=AlternatePaddedVector(<span class="hljs-number">1</span>/<span class="hljs-number">3</span>,<span class="hljs-number">4</span>/<span class="hljs-number">3</span>,<span class="hljs-number">4</span>/<span class="hljs-number">3</span>,<span class="hljs-number">1</span>/<span class="hljs-number">3</span>,N)
	<span class="hljs-keyword">return</span> dot(W,f_x)
<span class="hljs-keyword">end</span>

x2=randn(n2)
f_x2=@. sin(x2)+x2*cos(x2)
<span class="hljs-meta">@btime</span> f_simpson_std_scalar($f_x2);
<span class="hljs-meta">@btime</span> f_simpson_std_vec($f_x2);
<span class="hljs-meta">@btime</span> f_simpson_std_vec_linear_algebra($f_x2);
<span class="hljs-meta">@btime</span> f_simpson_apv($f_x2);
<span class="hljs-meta">@btime</span> f_simpson_apv_linear_algebra($f_x2);</code></pre><pre><code class="plaintext hljs">  9.267 μs (0 allocations: 0 bytes)
  5.921 μs (6 allocations: 156.39 KiB)
  3.492 μs (3 allocations: 78.20 KiB)
  3.927 μs (3 allocations: 78.20 KiB)
  9.277 μs (0 allocations: 0 bytes)
</code></pre>
<p>To be noticed the performance improvements thanks to the usage of AlternatePaddedVector, and to be noticed that the first function proposed is not compatible with the CUDA.jl stack.</p>
<p>      </div>
    </div>
  </div>
</section>
<footer class="py-5 bg-dark">
  <div class="container">
    <p class="m-0 text-center text-white">&copy; rcalxrc08. Website powered by <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a>, <a href="https://github.com/tlienart/PkgPage.jl">PkgPage.jl</a> and the <a href="https://julialang.org">Julia</a> programming language.</p>
  </div>
</footer>
</div><!-- CONTENT ENDS HERE -->
  
  
      


  
  <script src="/AlternateVectors.jl/libs/simple-scrollspy.min.js"></script>
  <script>
  window.onload = function () {
    scrollSpy('#navbarResponsive', {
      sectionClass: '.scrollspy',
      menuActiveTarget: '.nav-link',
      offset: 100
    })
  }
  </script>
  </body>
</html>
